import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { z } from 'zod'
import { DesignStatus, OrderStatus } from '@prisma/client'
import crypto from 'crypto'

const processOrderSchema = z.object({
  orderId: z.string().cuid(),
  autoFulfill: z.boolean().default(true)
})

function createFingerprint(data: {
  teamId: string
  sellerId?: string
  productSku: string
  artworkData?: any
  printSpecs?: any
}): string {
  const fingerprintData = {
    team: data.teamId,
    seller: data.sellerId || '',
    sku: data.productSku,
    artwork: JSON.stringify(data.artworkData || {}),
    specs: JSON.stringify(data.printSpecs || {})
  }
  
  return crypto
    .createHash('sha256')
    .update(JSON.stringify(fingerprintData))
    .digest('hex')
    .substring(0, 16)
}

async function getSellerFromStore(storeId: string) {
  const store = await prisma.store.findUnique({
    where: { id: storeId },
    include: {
      team: true
    }
  })
  
  return {
    id: store?.sellerId || store?.team.id || '',
    teamId: store?.team.id || ''
  }
}

async function findSellerDesign(teamId: string, fingerprint: string) {
  return await prisma.design.findFirst({
    where: {
      teamId,
      fingerprint,
      status: DesignStatus.ARCHIVED
    }
  })
}

async function createDesignFromOrder(orderData: any, teamId: string, sellerId: string) {
  const fingerprint = createFingerprint({
    teamId,
    sellerId,
    productSku: orderData.product.sku,
    artworkData: orderData.artworkData,
    printSpecs: orderData.printSpecs
  })
  
  return await prisma.design.create({
    data: {
      teamId,
      name: `Auto-generated: ${orderData.product.name}`,
      fingerprint,
      fileUrl: orderData.artworkData?.fileUrl || '',
      artworkData: orderData.artworkData,
      printSpecs: orderData.printSpecs,
      sellerId,
      status: DesignStatus.DRAFT,
      metadata: {
        autoGenerated: true,
        sourceOrderId: orderData.orderId,
        sourceOrderItem: orderData.id
      }
    }
  })
}

async function routeToFactory(orderId: string, orderItemId: string, designId?: string) {
  const factories = await prisma.factory.findMany({
    where: { isActive: true },
    orderBy: { capacity: 'desc' }
  })
  
  if (factories.length === 0) {
    throw new Error('No active factories available')
  }
  
  const selectedFactory = factories[0]
  
  return await prisma.fulfillment.create({
    data: {
      orderId,
      orderItemId,
      designId,
      factoryId: selectedFactory.id,
      status: 'QUEUED',
      estimatedAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      metadata: {
        routingReason: 'Auto-selected based on capacity',
        autoRouted: true
      }
    },
    include: {
      factory: true,
      design: true
    }
  })
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { orderId, autoFulfill } = processOrderSchema.parse(body)
    
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: {
        store: {
          include: {
            team: true
          }
        },
        items: {
          include: {
            product: true
          }
        }
      }
    })
    
    if (!order) {
      return NextResponse.json(
        { error: 'Order not found' },
        { status: 404 }
      )
    }
    
    if (order.status !== OrderStatus.PENDING) {
      return NextResponse.json(
        { error: 'Order has already been processed' },
        { status: 409 }
      )
    }
    
    const seller = await getSellerFromStore(order.storeId)
    const results = []
    
    for (const item of order.items) {
      const fingerprint = createFingerprint({
        teamId: seller.teamId,
        sellerId: seller.id,
        productSku: item.product.sku,
        artworkData: item.artworkData,
        printSpecs: item.printSpecs
      })
      
      const existingDesign = await findSellerDesign(seller.teamId, fingerprint)
      
      if (existingDesign && autoFulfill) {
        await prisma.orderItem.update({
          where: { id: item.id },
          data: { designId: existingDesign.id }
        })
        
        const fulfillment = await routeToFactory(order.id, item.id, existingDesign.id)
        
        results.push({
          orderItemId: item.id,
          status: 'AUTO_FULFILLED',
          designId: existingDesign.id,
          fulfillmentId: fulfillment.id,
          factory: fulfillment.factory.name
        })
      } else {
        const newDesign = await createDesignFromOrder({
          ...item,
          orderId: order.id,
          product: item.product
        }, seller.teamId, seller.id)
        
        await prisma.orderItem.update({
          where: { id: item.id },
          data: { designId: newDesign.id }
        })
        
        results.push({
          orderItemId: item.id,
          status: 'DESIGN_REQUIRED',
          designId: newDesign.id,
          message: 'Design created and assigned to designer'
        })
      }
    }
    
    const allAutoFulfilled = results.every(r => r.status === 'AUTO_FULFILLED')
    const newOrderStatus = allAutoFulfilled ? OrderStatus.PROCESSING : OrderStatus.PENDING
    
    await prisma.order.update({
      where: { id: orderId },
      data: { status: newOrderStatus }
    })
    
    await prisma.orderStatusHistory.create({
      data: {
        orderId,
        status: newOrderStatus,
        reason: allAutoFulfilled ? 'Auto-fulfilled' : 'Partial auto-fulfillment'
      }
    })
    
    return NextResponse.json({
      orderId,
      status: allAutoFulfilled ? 'FULLY_AUTO_FULFILLED' : 'PARTIALLY_AUTO_FULFILLED',
      results,
      summary: {
        totalItems: order.items.length,
        autoFulfilled: results.filter(r => r.status === 'AUTO_FULFILLED').length,
        requiresDesign: results.filter(r => r.status === 'DESIGN_REQUIRED').length
      }
    })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      )
    }
    
    console.error('Error processing order:', error)
    return NextResponse.json(
      { error: 'Failed to process order' },
      { status: 500 }
    )
  }
}